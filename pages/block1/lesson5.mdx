# Жизненный цикл компонента. Хук useEffect.1. Концепция жизненного цикла компонента
# 1. Жизненный цикл
## 1.1. Что такое жизненный цикл?
Жизненный цикл компонента — это последовательность этапов, которые проходит компонент от момента создания до удаления из DOM.

Основные этапы жизненного цикла:

![Жизненный цикл компонентов](/React-lifecycle.webp)

Монтирование (Mounting) — компонент создается и добавляется в DOM

Обновление (Updating) — компонент обновляется при изменении props или state

Размонтирование (Unmounting) — компонент удаляется из DOM

## 1.2. Жизненный цикл в классовых компонентах (историческая справка)
```jsx
class ClassComponent extends React.Component {
  // 1. Монтирование
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  
  componentDidMount() {
    // Выполняется после первого рендера
    console.log('Компонент монтирован в DOM');
  }
  
  componentDidUpdate(prevProps, prevState) {
    // Выполняется после обновления
    if (prevState.count !== this.state.count) {
      console.log('Count изменился');
    }
  }
  
  componentWillUnmount() {
    // Выполняется перед удалением компонента
    console.log('Компонент будет удален');
  }
  
  render() {
    return <div>Count: {this.state.count}</div>;
  }
}
```
Проблемы классового подхода:

Сложность переиспользования логики

Большой объем boilerplate-кода

Логика размазана по разным методам

Сложность тестирования [1]

# 2. Введение в хук useEffect
## 2.1. Что такое побочные эффекты?
Побочные эффекты (side effects) — это любые операции, которые выходят за рамки рендеринга компонента:

Работа с API: запросы к серверу

Подписки на события: WebSocket, таймеры, DOM-события

Изменение DOM: вручную, не через React

Работа с внешними системами: localStorage, геолокация

## 2.2. Синтаксис useEffect
```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Побочный эффект выполняется здесь
    console.log('Эффект выполнен');
    
    // Опционально: функция очистки
    return () => {
      console.log('Очистка эффекта');
    };
  }, [dependencies]); // Массив зависимостей
  
  return <div>Мой компонент</div>;
}
```
Параметры useEffect:

Функция эффекта — содержит логику побочного эффекта

Массив зависимостей — определяет, когда эффект должен выполняться

Функция очистки — выполняется перед повторным вызовом эффекта или размонтированием

## 3. Варианты использования useEffect
### 3.1. Запуск эффекта после каждого рендера
```jsx
function EffectAfterRender() {
  const [count, setCount] = useState(0);
  
  // Выполняется после КАЖДОГО рендера
  useEffect(() => {
    console.log('Компонент отрендерен, count:', count);
    
    // Обновление заголовка документа
    document.title = `Count: ${count}`;
  }); // Нет массива зависимостей
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}
```
Когда используется:

Отслеживание всех изменений компонента

Логирование для отладки

Обновление DOM, не связанное с конкретными данными

### 3.2. Запуск эффекта только при монтировании
```jsx
function EffectOnMount() {
  const [data, setData] = useState(null);
  
  // Выполняется только при МОНТИРОВАНИИ
  useEffect(() => {
    console.log('Компонент монтирован - выполняется только один раз');
    
    // Загрузка данных при монтировании
    fetch('/api/data')
      .then(response => response.json())
      .then(data => setData(data));
  }, []); // Пустой массив зависимостей
  
  return (
    <div>
      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : 'Загрузка...'}
    </div>
  );
}
```
Когда используется:

Загрузка начальных данных

Настройка подписок (с осторожностью)

Инициализация сторонних библиотек

Отправка аналитических событий

### 3.3. Запуск эффекта при изменении зависимостей
```jsx
function EffectWithDependencies() {
  const [user, setUser] = useState({ id: 1, name: '' });
  const [profile, setProfile] = useState(null);
  
  // Выполняется при изменении user.id
  useEffect(() => {
    console.log('ID пользователя изменился:', user.id);
    
    // Загрузка профиля при изменении ID пользователя
    if (user.id) {
      fetch(`/api/users/${user.id}`)
        .then(response => response.json())
        .then(profile => setProfile(profile));
    }
  }, [user.id]); // Зависимость от user.id
  
  return (
    <div>
      <input 
        value={user.name}
        onChange={(e) => setUser({ ...user, name: e.target.value })}
        placeholder="Имя пользователя"
      />
      <button onClick={() => setUser({ ...user, id: user.id + 1 })}>
        Следующий пользователь
      </button>
      
      {profile && (
        <div>
          <h3>Профиль: {profile.name}</h3>
          <p>Email: {profile.email}</p>
        </div>
      )}
    </div>
  );
}
```
Когда используется:

Загрузка данных при изменении параметров

Синхронизация с внешними системами

Выполнение операций при изменении конкретных значений

## 4. Функция очистки эффектов
### 4.1. Зачем нужна очистка?
Функция очистки предотвращает:

Утечки памяти: незакрытые подписки и таймеры

Ошибки выполнения: попытки обновить состояние размонтированного компонента

Некорректное поведение: накопление нескольких экземпляров эффектов

### 4.2. Примеры очистки
Очистка таймеров:

```jsx
function TimerComponent() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('Таймер запущен');
    
    const intervalId = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);
    
    // Функция очистки
    return () => {
      console.log('Таймер очищен');
      clearInterval(intervalId);
    };
  }, []); // Только при монтировании/размонтировании
  
  return <div>Счетчик: {count}</div>;
}
```
Очистка подписок на события:

```jsx
function ResizeListener() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    console.log('Подписка на resize событие');
    
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    
    // Функция очистки
    return () => {
      console.log('Отписка от resize события');
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return (
    <div>
      Размер окна: {windowSize.width} x {windowSize.height}
    </div>
  );
}
```
Очистка WebSocket соединений:

```jsx
function WebSocketComponent({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() => {
    console.log('Подключение к WebSocket для комнаты:', roomId);
    
    const ws = new WebSocket(`ws://localhost:8080/rooms/${roomId}`);
    
    ws.onmessage = (event) => {
      const newMessage = JSON.parse(event.data);
      setMessages(prev => [...prev, newMessage]);
    };
    
    // Функция очистки
    return () => {
      console.log('Закрытие WebSocket соединения');
      ws.close();
    };
  }, [roomId]); // Переподключаемся при смене roomId
  
  return (
    <div>
      <h3>Комната: {roomId}</h3>
      <div>
        {messages.map((msg, index) => (
          <div key={index}>{msg.text}</div>
        ))}
      </div>
    </div>
  );
}
```
## 5. Практические примеры и паттерны
### 5.1. Работа с API
```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    // Отменяем предыдущие запросы при изменении userId
    let cancelled = false;
    
    const fetchUser = async () => {
      if (!userId) return;
      
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(`/api/users/${userId}`);
        
        if (!response.ok) {
          throw new Error('Пользователь не найден');
        }
        
        const userData = await response.json();
        
        // Не обновляем состояние если компонент размонтирован
        if (!cancelled) {
          setUser(userData);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchUser();
    
    // Функция очистки - отменяем запрос если компонент размонтирован
    return () => {
      cancelled = true;
    };
  }, [userId]); // Перезапускаем при изменении userId
  
  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;
  if (!user) return <div>Пользователь не выбран</div>;
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>Email: {user.email}</p>
      <p>Город: {user.city}</p>
    </div>
  );
}
```
### 5.2. Кастомный хук для работы с данными
```jsx
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!cancelled) {
          setData(result);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, [url]); // Перезапускаем при изменении URL
  
  return { data, loading, error };
}

// Использование кастомного хука
function PostsList() {
  const { data: posts, loading, error } = useApi('/api/posts');
  
  if (loading) return <div>Загрузка постов...</div>;
  if (error) return <div>Ошибка: {error}</div>;
  
  return (
    <div>
      <h2>Список постов</h2>
      {posts.map(post => (
        <div key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.body}</p>
        </div>
      ))}
    </div>
  );
}
```
### 5.3. Управление состоянием документа
```jsx
function DocumentTitleUpdater({ title }) {
  // Обновление заголовка документа
  useEffect(() => {
    document.title = title;
  }, [title]); // Обновляем только при изменении title
  
  return <div>Текущий заголовок: "{title}"</div>;
}

function ScrollToTop() {
  // Прокрутка к верху страницы при монтировании
  useEffect(() => {
    window.scrollTo(0, 0);
  }, []); // Только при монтировании
  
  return null;
}

function OnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  // Отслеживание онлайн-статуса
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return (
    <div style={{ color: isOnline ? 'green' : 'red' }}>
      {isOnline ? 'Онлайн' : 'Офлайн'}
    </div>
  );
}
```
### 5.4. Работа с localStorage
```jsx
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Ошибка чтения localStorage ключа "${key}":`, error);
      return initialValue;
    }
  });
  
  // Обновляем localStorage при изменении значения
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(storedValue));
    } catch (error) {
      console.error(`Ошибка записи в localStorage ключа "${key}":`, error);
    }
  }, [key, storedValue]);
  
  return [storedValue, setStoredValue];
}

// Компонент настроек с сохранением в localStorage
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const [language, setLanguage] = useLocalStorage('language', 'ru');
  const [notifications, setNotifications] = useLocalStorage('notifications', true);
  
  return (
    <div>
      <h2>Настройки</h2>
      
      <div>
        <label>Тема:</label>
        <select value={theme} onChange={(e) => setTheme(e.target.value)}>
          <option value="light">Светлая</option>
          <option value="dark">Темная</option>
        </select>
      </div>
      
      <div>
        <label>Язык:</label>
        <select value={language} onChange={(e) => setLanguage(e.target.value)}>
          <option value="ru">Русский</option>
          <option value="en">Английский</option>
        </select>
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            checked={notifications}
            onChange={(e) => setNotifications(e.target.checked)}
          />
          Уведомления
        </label>
      </div>
    </div>
  );
}
```
## 6. Распространенные ошибки и лучшие практики
### 6.1. Частые ошибки
Ошибка 1: Бесконечные циклы

```jsx
// ❌ НЕПРАВИЛЬНО - бесконечный цикл
const [count, setCount] = useState(0);

useEffect(() => {
  setCount(count + 1); // Вызывает ререндер, который снова запускает эффект
}); // Нет зависимостей - выполняется после каждого рендера

// ✅ ПРАВИЛЬНО - указаны зависимости
useEffect(() => {
  // Логика без обновления состояния, создающего цикл
}, [someDependency]);
```
Ошибка 2: Отсутствие зависимостей

```jsx
// ❌ НЕПРАВИЛЬНО - эффект использует count, но не указан в зависимостях
const [count, setCount] = useState(0);

useEffect(() => {
  document.title = `Count: ${count}`;
}, []); // Пустой массив - эффект выполняется только один раз

// ✅ ПРАВИЛЬНО - count указан в зависимостях
useEffect(() => {
  document.title = `Count: ${count}`;
}, [count]);\
```
Ошибка 3: Неправильная очистка

```jsx
// ❌ НЕПРАВИЛЬНО - утечка памяти
useEffect(() => {
  const intervalId = setInterval(() => {
    console.log('Таймер работает');
  }, 1000);
  
  // Нет функции очистки - таймер продолжает работать после размонтирования
}, []);

// ✅ ПРАВИЛЬНО - очистка таймера
useEffect(() => {
  const intervalId = setInterval(() => {
    console.log('Таймер работает');
  }, 1000);
  
  return () => {
    clearInterval(intervalId);
  };
}, []);
```
### 6.2. Лучшие практики
Практика 1: Разделение эффектов по ответственности

``` jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  
  // ❌ ПЛОХО - несколько несвязанных эффектов в одном
  useEffect(() => {
    // Загрузка пользователя
    fetchUser(userId).then(setUser);
    
    // Загрузка постов
    fetchUserPosts(userId).then(setPosts);
    
    // Обновление заголовка
    document.title = user ? `Профиль ${user.name}` : 'Загрузка...';
  }, [userId]);
  
  // ✅ ХОРОШО - разделение на логические эффекты
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  useEffect(() => {
    fetchUserPosts(userId).then(setPosts);
  }, [userId]);
  
  useEffect(() => {
    document.title = user ? `Профиль ${user.name}` : 'Загрузка...';
  }, [user]);
  
  // ...
}
```
Практика 2: Использование useCallback для стабильных функций

``` jsx
function ProductList({ category }) {
  const [products, setProducts] = useState([]);
  
  // ❌ ПЛОХО - функция создается заново при каждом рендере
  const fetchProducts = () => {
    fetch(`/api/products?category=${category}`)
      .then(response => response.json())
      .then(setProducts);
  };
  
  useEffect(() => {
    fetchProducts();
  }, [fetchProducts]); // fetchProducts меняется при каждом рендере
  
  // ✅ ХОРОШО - стабильная функция с useCallback
  const fetchProducts = useCallback(() => {
    fetch(`/api/products?category=${category}`)
      .then(response => response.json())
      .then(setProducts);
  }, [category]); // Зависит только от category
  
  useEffect(() => {
    fetchProducts();
  }, [fetchProducts]);
  
  // ...
}
```
Практика 3: Использование useRef для значений, не участвующих в рендеринге

```jsx
function TimerWithRef() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);
  
  useEffect(() => {
    intervalRef.current = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
    
    return () => {
      clearInterval(intervalRef.current);
    };
  }, []);
  
  const stopTimer = () => {
    clearInterval(intervalRef.current);
  };
  
  return (
    <div>
      <div>Счетчик: {count}</div>
      <button onClick={stopTimer}>Остановить</button>
    </div>
  );
}
```
## 7. Сравнение с классовыми компонентами
|Функциональный компонент с useEffect          |	Классовый компонент|
|```useEffect(() => { ... })```                      |	componentDidMount() + componentDidUpdate()|
|```useEffect(() => { ... }, [])```                  |	componentDidMount()|
|```useEffect(() => { ... }, [dep])```               |	componentDidUpdate(prevProps, prevState)|
|```useEffect(() => { return () => { ... } }, [])``` |	componentWillUnmount()|
```jsx
// Функциональный компонент с useEffect
function FunctionalComponent({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
    
    return () => {
      // Очистка
    };
  }, [userId]);
  
  return <div>{user?.name}</div>;
}

// Эквивалентный классовый компонент
class ClassComponent extends React.Component {
  state = { user: null };
  
  componentDidMount() {
    this.fetchUser(this.props.userId);
  }
  
  componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      this.fetchUser(this.props.userId);
    }
  }
  
  componentWillUnmount() {
    // Очистка
  }
  
  fetchUser = (userId) => {
    fetchUser(userId).then(user => this.setState({ user }));
  };
  
  render() {
    return <div>{this.state.user?.name}</div>;
  }
}
```


## Выводы
useEffect объединяет логику componentDidMount, componentDidUpdate и componentWillUnmount

Эффекты выполняются после рендера, не блокируя обновление UI

Массив зависимостей определяют, когда эффект должен перезапускаться

Очистка необходима для предотвращения утечек памяти и ошибок

Разделение эффектов по ответственности улучшает читаемость кода

Правила Hooks должны соблюдаться для корректной работы

## Дополнительные материалы
1. [React Docs - useEffect](https://react.dev/reference/react/useEffect)

2. [Полное руководство по useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

3. [Практические примеры useEffect](https://metanit.com/web/react/3.4.php)