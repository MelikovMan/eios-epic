# Урок: Хук useContext
## 1. Введение в проблему
### 1.1. Проблема проп drilling
Проп drilling — это ситуация, когда данные передаются через множество уровней компонентов, которые сами эти данные не используют.

```jsx
// ❌ ПРОБЛЕМА: Проп drilling
function App() {
  const [user, setUser] = useState({ name: 'Анна', theme: 'dark' });
  
  return (
    <div>
      <Header user={user} setUser={setUser} />
    </div>
  );
}

function Header({ user, setUser }) {
  // Header не использует user, но передает его дальше
  return (
    <header>
      <Navigation user={user} setUser={setUser} />
    </header>
  );
}

function Navigation({ user, setUser }) {
  // Navigation не использует user, но передает его дальше
  return (
    <nav>
      <UserMenu user={user} setUser={setUser} />
    </nav>
  );
}

function UserMenu({ user, setUser }) {
  // Только здесь user действительно используется
  return (
    <div>
      <span>Привет, {user.name}</span>
      <button onClick={() => setUser({...user, theme: user.theme === 'dark' ? 'light' : 'dark'})}>
        Сменить тему
      </button>
    </div>
  );
}
```
Проблемы проп drilling:

Сложность рефакторинга

Ненужные перерисовки компонентов

Усложнение кода

Сложность отслеживания потока данных

## 2. Создание и использование контекста
### 2.1. Базовое создание контекста
```jsx
import { createContext, useContext, useState } from 'react';

// 1. Создаем контекст
const UserContext = createContext();

// 2. Создаем провайдер
function UserProvider({ children }) {
  const [user, setUser] = useState({
    name: 'Анна',
    theme: 'dark',
    email: 'anna@example.com'
  });
  
  const updateUser = (updates) => {
    setUser(prev => ({ ...prev, ...updates }));
  };
  
  // Значение, которое будет доступно через контекст
  const value = {
    user,
    updateUser
  };
  
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

// 3. Создаем кастомный хук для использования контекста
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser должен использоваться внутри UserProvider');
  }
  return context;
}
```
### 2.2. Использование в приложении
```jsx
// ✅ РЕШЕНИЕ: Использование контекста
function App() {
  return (
    <UserProvider>
      <div>
        <Header />
      </div>
    </UserProvider>
  );
}

function Header() {
  // Header больше не получает пропсы
  return (
    <header>
      <Navigation />
    </header>
  );
}

function Navigation() {
  // Navigation больше не получает пропсы
  return (
    <nav>
      <UserMenu />
    </nav>
  );
}

function UserMenu() {
  // Получаем данные напрямую из контекста
  const { user, updateUser } = useUser();
  
  return (
    <div>
      <span>Привет, {user.name}</span>
      <button onClick={() => updateUser({ 
        theme: user.theme === 'dark' ? 'light' : 'dark' 
      })}>
        Сменить тему
      </button>
    </div>
  );
}
```
### 2.3. Диграмма сравнения использование контекста
![React контекст](/react-context.webp)

## 3. Практические примеры

### 3.1. Контекст темы
```jsx
import { createContext, useContext, useState, useMemo } from 'react';

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  // useMemo для оптимизации - значение обновляется только при изменении theme
  const value = useMemo(() => ({
    theme,
    toggleTheme,
    isDark: theme === 'dark'
  }), [theme]);
  
  return (
    <ThemeContext.Provider value={value}>
      <div className={`app ${theme}`}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme должен использоваться внутри ThemeProvider');
  }
  return context;
}

// Использование в компонентах
function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <button onClick={toggleTheme}>
      Переключить на {theme === 'light' ? 'тёмную' : 'светлую'} тему
    </button>
  );
}

function ThemedComponent() {
  const { theme, isDark } = useTheme();
  
  return (
    <div style={{
      backgroundColor: isDark ? '#333' : '#fff',
      color: isDark ? '#fff' : '#333',
      padding: '20px'
    }}>
      Текущая тема: {theme}
    </div>
  );
}
```
### 3.2. Контекст аутентификации
```jsx
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const login = async (email, password) => {
    setLoading(true);
    try {
      // Имитация API запроса
      const response = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify({ email, password })
      });
      const userData = await response.json();
      setUser(userData);
    } catch (error) {
      console.error('Ошибка входа:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };
  
  const logout = () => {
    setUser(null);
  };
  
  const value = useMemo(() => ({
    user,
    login,
    logout,
    loading,
    isAuthenticated: !!user
  }), [user, loading]);
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth должен использоваться внутри AuthProvider');
  }
  return context;
}

// Компонент входа
function LoginForm() {
  const { login, loading } = useAuth();
  const [formData, setFormData] = useState({ email: '', password: '' });
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await login(formData.email, formData.password);
    } catch (error) {
      alert('Ошибка входа');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={formData.email}
        onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
        placeholder="Email"
      />
      <input
        type="password"
        value={formData.password}
        onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
        placeholder="Пароль"
      />
      <button type="submit" disabled={loading}>
        {loading ? 'Вход...' : 'Войти'}
      </button>
    </form>
  );
}

// Защищенный компонент
function UserProfile() {
  const { user, logout } = useAuth();
  
  if (!user) {
    return <div>Пожалуйста, войдите в систему</div>;
  }
  
  return (
    <div>
      <h2>Добро пожаловать, {user.name}!</h2>
      <p>Email: {user.email}</p>
      <button onClick={logout}>Выйти</button>
    </div>
  );
}
```
## 4. Лучшие практики
### 4.1. Разделение контекстов
```jsx
// ❌ ПЛОХО: Один контекст для всего
const AppContext = createContext();

// ✅ ХОРОШО: Разделенные контексты
const AuthContext = createContext();
const ThemeContext = createContext();
const NotificationContext = createContext();

function AppProviders({ children }) {
  return (
    <ThemeProvider>
      <AuthProvider>
        <NotificationProvider>
          {children}
        </NotificationProvider>
      </AuthProvider>
    </ThemeProvider>
  );
}
```

## 5. Когда использовать контекст
✅ Используйте контекст для:
Тематизации приложения

Данных аутентификации

Локализации (i18n)

Глобальных настроек

Данных, используемых во многих компонентах

❌ Не используйте контекст для:
Данных, используемых одним компонентом

Часто изменяющихся данных (кроме оптимизированных случаев)

Замены глобальному состоянию (Redux, Zustand) в сложных приложениях


## Выводы
useContext решает проблему проп drilling

Контекст состоит из Provider и Consumer (через useContext)

Разделяйте контексты по логическим доменам

Используйте кастомные хуки для удобства использования

Контекст — это мощный инструмент, но используйте его там, где он действительно нужен!