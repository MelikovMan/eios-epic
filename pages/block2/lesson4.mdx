# Библиотеки для управления состоянием React

## 1. Введение в управление состоянием
### 1.1. Когда встроенных возможностей React недостаточно?
Встроенные средства React хороши для:

Локального состояния компонентов

Простого подъема состояния

Контекста для редких обновлений

Проблемы, требующие внешних решений:

```jsx
// ❌ СЛОЖНОСТЬ: Множественные перерисовки с Context
const AppStateContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [products, setProducts] = useState([]);
  const [cart, setCart] = useState([]);
  const [notifications, setNotifications] = useState([]);
  
  const value = {
    user, setUser,
    products, setProducts,
    cart, setCart,
    notifications, setNotifications
  };
  
  return (
    <AppStateContext.Provider value={value}>
      {children}
    </AppStateContext.Provider>
  );
}

// Любое изменение перерисовывает ВСЕ компоненты использующие контекст!
function ProductList() {
  const { products } = useContext(AppStateContext); // Перерисовывается при изменении cart!
  return <div>{products.map(p => <Product key={p.id} {...p} />)}</div>;
}
```

## 2. Redux Toolkit (RTK) - промышленное решение
### 2.1. Современный Redux - не ваш дедушкин Redux
```jsx
// store/store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

// Создание slice (редюсер + действия)
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1; // Можно "мутировать" - Immer под капотом!
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});

// Автоматически генерируются action creators
export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// Настройка store
export const store = configureStore({
  reducer: {
    counter: counterSlice.reducer,
    // Можно добавить другие редюсеры
  },
});

// Типы для TypeScript
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```
### 2.2. Использование в компонентах с хуками
```jsx
// hooks/redux.js
import { useDispatch, useSelector } from 'react-redux';
import { TypedUseSelectorHook } from 'react-redux';

// Типизированные хуки
export const useAppDispatch = () => useDispatch();
export const useAppSelector = useSelector;

// Компонент с Redux
function Counter() {
  const count = useAppSelector((state) => state.counter.value);
  const dispatch = useAppDispatch();

  return (
    <div>
      <span>Count: {count}</span>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(incrementByAmount(5))}>+5</button>
    </div>
  );
}

// Provider в корне приложения
import { Provider } from 'react-redux';
import { store } from './store';

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}
```
### 2.3. Асинхронные действия с createAsyncThunk
```jsx
// store/productsSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Асинхронный thunk
export const fetchProducts = createAsyncThunk(
  'products/fetchProducts',
  async (categoryId, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/products?category=${categoryId}`);
      if (!response.ok) throw new Error('Server error');
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const productsSlice = createSlice({
  name: 'products',
  initialState: {
    items: [],
    loading: false,
    error: null,
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const { clearError } = productsSlice.actions;
export default productsSlice.reducer;
2.4. RTK Query для работы с API
jsx
// store/api.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Products', 'Users'],
  endpoints: (builder) => ({
    getProducts: builder.query({
      query: (category) => `/products?category=${category}`,
      providesTags: ['Products'],
    }),
    getUser: builder.query({
      query: (id) => `/users/${id}`,
      providesTags: (result, error, id) => [{ type: 'Users', id }],
    }),
    addProduct: builder.mutation({
      query: (newProduct) => ({
        url: '/products',
        method: 'POST',
        body: newProduct,
      }),
      invalidatesTags: ['Products'],
    }),
  }),
});

export const { 
  useGetProductsQuery, 
  useGetUserQuery, 
  useAddProductMutation 
} = api;

// Использование в компоненте
function ProductsList({ category }) {
  const { data: products, isLoading, error } = useGetProductsQuery(category);
  const [addProduct] = useAddProductMutation();

  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div>
      {products.map(product => (
        <Product key={product.id} product={product} />
      ))}
    </div>
  );
}
```
## 3. Zustand - минималистичный подход
### 3.1. Простота использования
```jsx
// store/useStore.js
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

// Базовый store
const useStore = create((set, get) => ({
  // State
  count: 0,
  user: null,
  products: [],
  
  // Actions
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
  
  // Асинхронные действия
  fetchUser: async (id) => {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    set({ user });
  },
  
  // Действия, использующие текущее состояние
  incrementBy: (amount) => {
    const { count } = get();
    set({ count: count + amount });
  },
}));

// Store с middleware
const useAuthStore = create(
  devtools(
    persist(
      (set, get) => ({
        user: null,
        token: null,
        login: async (credentials) => {
          const response = await fetch('/api/login', {
            method: 'POST',
            body: JSON.stringify(credentials),
          });
          const { user, token } = await response.json();
          set({ user, token });
        },
        logout: () => set({ user: null, token: null }),
      }),
      {
        name: 'auth-storage', // ключ для localStorage
      }
    )
  )
);
```
### 3.2. Использование в компонентах
```jsx
// Компоненты с Zustand
function Counter() {
  const { count, increment, decrement } = useStore();
  
  return (
    <div>
      <span>{count}</span>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}

// Селекторы для оптимизации перерисовок
function UserProfile() {
  const user = useStore((state) => state.user);
  const fetchUser = useStore((state) => state.fetchUser);
  
  useEffect(() => {
    fetchUser(1);
  }, [fetchUser]);
  
  return <div>{user?.name}</div>;
}

// Кастомный хук для сложной логики
function useProducts() {
  const products = useStore((state) => state.products);
  const fetchProducts = useStore((state) => state.fetchProducts);
  
  const expensiveProducts = useMemo(() => {
    return products.filter(p => p.price > 100);
  }, [products]);
  
  return { products: expensiveProducts, fetchProducts };
}
```
### 3.3. Продвинутые паттерны с Zustand
```jsx
// Типизированный store с TypeScript
import { create } from 'zustand';
import { combine } from 'zustand/middleware';

interface UserState {
  user: User | null;
  login: (user: User) => void;
  logout: () => void;
}

interface CartState {
  items: CartItem[];
  addItem: (item: CartItem) => void;
  removeItem: (id: string) => void;
}

const useUserStore = create<UserState>((set) => ({
  user: null,
  login: (user) => set({ user }),
  logout: () => set({ user: null }),
}));

const useCartStore = create<CartState>((set) => ({
  items: [],
  addItem: (item) => set((state) => ({ 
    items: [...state.items, item] 
  })),
  removeItem: (id) => set((state) => ({
    items: state.items.filter(item => item.id !== id)
  })),
}));

// Комбинированный store
const useAppStore = create(
  combine(
    { count: 0 },
    (set) => ({
      increment: () => set((state) => ({ count: state.count + 1 })),
    })
  )
);
```
## 4. Jotai - атомарное состояние
### 4.1. Концепция атомов
```jsx
// store/atoms.js
import { atom } from 'jotai';

// Базовые атомы
export const countAtom = atom(0);
export const userAtom = atom(null);
export const productsAtom = atom([]);

// Производные атомы (computed)
export const doubledCountAtom = atom((get) => get(countAtom) * 2);
export const expensiveProductsAtom = atom((get) => 
  get(productsAtom).filter(p => p.price > 100)
);

// Атомы с действиями
export const countActionsAtom = atom(
  (get) => get(countAtom),
  (get, set, action) => {
    switch (action.type) {
      case 'increment':
        set(countAtom, get(countAtom) + 1);
        break;
      case 'decrement':
        set(countAtom, get(countAtom) - 1);
        break;
      case 'reset':
        set(countAtom, 0);
        break;
    }
  }
);
```
### 4.2. Использование в компонентах
```jsx
import { useAtom, useAtomValue, useSetAtom } from 'jotai';

function Counter() {
  const [count, setCount] = useAtom(countAtom);
  const doubledCount = useAtomValue(doubledCountAtom);
  
  return (
    <div>
      <span>Count: {count}</span>
      <span>Doubled: {doubledCount}</span>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}

// Оптимизированные компоненты
function ProductCount() {
  const productCount = useAtomValue(
    atom((get) => get(productsAtom).length)
  );
  
  return <div>Total products: {productCount}</div>;
}

// Действия с атомами
function CounterActions() {
  const [count, dispatch] = useAtom(countActionsAtom);
  
  return (
    <div>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  );
}
```
### 4.3. Асинхронные атомы
```jsx
// Асинхронные атомы
export const userDataAtom = atom(async (get) => {
  const userId = get(currentUserIdAtom);
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
});

// Атомы с загрузкой данных
export const fetchProductsAtom = atom(
  (get) => get(productsAtom),
  async (get, set, category) => {
    const response = await fetch(`/api/products?category=${category}`);
    const products = await response.json();
    set(productsAtom, products);
  }
);

// Использование с Suspense
function UserProfile() {
  const user = useAtomValue(userDataAtom); // Может "подвесить" компонент
  
  return <div>{user.name}</div>;
}

function ProductsManager() {
  const [products, fetchProducts] = useAtom(fetchProductsAtom);
  
  useEffect(() => {
    fetchProducts('electronics');
  }, [fetchProducts]);
  
  return <div>{products.map(p => <Product key={p.id} {...p} />)}</div>;
}
```
## 5. Valtio - прокси-подход
### 5.1. Реактивное состояние
```jsx
// store/state.js
import { proxy, useSnapshot } from 'valtio';

// Создание состояния
const appState = proxy({
  count: 0,
  user: null,
  products: [],
  get doubledCount() {
    return this.count * 2;
  },
  get expensiveProducts() {
    return this.products.filter(p => p.price > 100);
  }
});

// Действия
export const appActions = {
  increment: () => {
    appState.count += 1;
  },
  decrement: () => {
    appState.count -= 1;
  },
  async fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    appState.user = await response.json();
  },
  addProduct(product) {
    appState.products.push(product);
  }
};
```
### 5.2. Использование в компонентах
```jsx
function Counter() {
  const snap = useSnapshot(appState);
  
  return (
    <div>
      <span>Count: {snap.count}</span>
      <span>Doubled: {snap.doubledCount}</span>
      <button onClick={appActions.increment}>+</button>
    </div>
  );
}

// Селективное подписывание на изменения
function ProductList() {
  const products = useSnapshot(appState).products;
  
  return (
    <div>
      {products.map(product => (
        <Product key={product.id} product={product} />
      ))}
    </div>
  );
}

// Оптимизация с subscribe
function ProductCount() {
  const [count, setCount] = useState(appState.products.length);
  
  useEffect(() => {
    return subscribe(appState.products, () => {
      setCount(appState.products.length);
    });
  }, []);
  
  return <div>Products: {count}</div>;
}
```
## 6. Сравнительный анализ
|Библиотека	    |Размер	|Подход	                |Кривая обучения	|Лучший случай использования|
|Redux Toolkit	|~9KB	|Flux	                |Средняя	        |Крупные приложения, команды|
|Zustand	    |~1KB	|Публишатель/подписчик	|Низкая	            |Малые/средние приложения   |
|Jotai	        |~3KB	|Атомарный	            |Средняя	        |Производные состояния      |
|Valtio	        |~4KB	|Прокси		            |Низкая             |Реактивное программирование|



## Выводы
Redux Toolkit - промышленное решение для больших приложений

Zustand - минималистичный и простой в использовании

Jotai - атомарный подход для производных состояний

Valtio - реактивное программирование с прокси

Выбор зависит от размера приложения, опыта команды и требований

Гибридные подходы возможны и иногда предпочтительны

Тестируемость должна учитываться при выборе библиотеки

## Дополнительные материалы
1. [Redux Toolkit Documentation](https://redux-toolkit.js.org/)

2. [Zustand GitHub](https://github.com/pmndrs/zustand)

3. [Jotai GitHub](https://github.com/pmndrs/jotai)

4. [Valtio GitHub](https://github.com/pmndrs/valtio)

Помните: Нет "серебряной пули" - выбирайте инструмент под конкретные задачи вашего проекта!

Следующий урок: Тестирование React-приложений!